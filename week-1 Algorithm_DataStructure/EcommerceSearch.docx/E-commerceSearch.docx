//Understanding Asymptotic Notation

Big O Notation:
- Big O notation describes the upper bound (worst-case) time or space complexity of an algorithm.
- It helps developers predict how the algorithm will scale with larger input sizes.
- Focuses on how runtime grows with input size 'n', ignoring constant factors.

Common Big O Complexities:
- O(1): Constant time (fastest)
- O(log n): Logarithmic time
- O(n): Linear time
- O(n log n): Log-linear time (e.g., efficient sorts)
- O(n^2): Quadratic time (e.g., nested loops)

Search Time Complexities:

1. Linear Search:
   - Best Case: O(1) (element is first)
   - Average Case: O(n/2) â‰ˆ O(n)
   - Worst Case: O(n)

2. Binary Search:
   - Best Case: O(1) (middle element match)
   - Average Case: O(log n)
   - Worst Case: O(log n)
   - Requires the array to be sorted before search

Use in E-commerce:
- Binary Search is preferable for large, sorted product databases.
- Linear Search is simple but not scalable for large datasets.
// Analysis
     E-commerce Platform Search Function - Analysis

Search Algorithms Implemented:
1. Linear Search:
   - Time Complexity: O(n)
   - Works on unsorted data.
   - Suitable for small or unsorted datasets.

2. Binary Search:
   - Time Complexity: O(log n)
   - Requires sorted array.
   - Much faster for large, sorted datasets.

Use Case Discussion:
- Linear Search is easier to implement but slow for large data.
- Binary Search is efficient but needs data to be sorted.
- For e-commerce platforms with frequent searches, binary search or indexing via HashMap/Trie is recommended.
